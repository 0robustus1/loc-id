\documentclass[a4paper,11pt,DIV=22]{scrartcl}

\usepackage[utf8x]{inputenc}
% \usepackage[ngerman]{babel}
\usepackage{longtable}
\usepackage{listings}
\usepackage{multirow}
%\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{courier}
\usepackage{hyperref}

\lstset{ %
  basicstyle=\small\ttfamily,
  % framextopmargin=50pt,
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  % commentstyle=\color{mygreen},    % comment style
  % deletekeywords={...},            % if you want to delete keywords from the given language
  % escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  % keywordstyle=\color{blue},       % keyword style
  % morekeywords={*,...},            % if you want to add more keywords to the set
  % numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  % numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  % rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  % showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  % showstringspaces=false,          % underline spaces within strings only
  % showtabs=false,                  % show tabs within strings adding particular underscores
  % stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  % stringstyle=\color{mymauve},     % string literal style
  % tabsize=2,                       % sets default tabsize to 2 spaces
  % title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\author{Tim Reddehase}
\date{2015-02-22}

\newenvironment{oitemize}{%
  \renewcommand{\labelitemii}{$\bullet$}%
  \vspace{-15pt}
  \begin{itemize}}
  {\end{itemize}}

\begin{document}

\Huge
\begin{center}
  Ontohub loc/id (v2, Draft)\\
  \bigskip
  \includegraphics[width=0.3\textwidth]{ontohub-loc_id-logo.pdf}
\end{center}
\normalsize

\bigskip

\section{Concept}

Generally an Ontohub loc/id (locator/identifier) is just an IRI of an ontology
or one of its members (symbols, sentences, mappings, child-ontologies). However
Ontohub loc/ids are generated by the Ontohub application and assigned to an
ontology.  We try to infer them from the path of the repository, the path of
the ontology and the specific name. Additionally we ensure that this specific
IRI is actually a locator and not \emph{just} an identifier.

This is quite important as the IRI of an ontology is the general starting
interface a user has with the given ontology. When she evaluates the ontology
in her tool of choice she'll use the IRI to reference the given ontology. When
she wants to work on ontohub with the given ontology she'll point her browser
at the given IRI. As one familiarity with the Ontohub application increases one
will more often want to use the IRI instead of just searching or even browsing
for something.  This is further intensified if the IRI-schema follows a schema
that is easily understood by a user.

\section{Ontohub-Style}

Identifying Ontologies and their members in Ontohub is a hierarchical task. An
ontology belongs to a repository and a child-ontology belongs to a parent
ontology. Mappings, symbols and sentences in turn belong to a ontology. So we
could use the hierarchical portion of an IRI instead of the query string.
This would means using a forward slash (\emph{/}) as separator.

Ontohub loc/ids are specific to an instance of the Ontohub-Application. However
such an instance might be reachable via multiple multiple FQDNs (fully
qualified domain name) and ports. So instead we should expect a
\emph{qualified loc/id} to be a tuple consisting of the specific application
instance, represented by the set of their schema-fqdn-port tuples, and the
actual identifying portion beginning with the hierarchical forward slash
(\emph{/}).

\subsection{qualified loc/id structure}

\begin{enumerate}
  \item Set of Schema + FQDNs + Port for an instance: \textbf{INSTANCE}, e.g.\\
    \{ \url{http://localhost:3000}, \url{http://localhost:9001}, \url{http://ontohub.dev} \}
  \item Identifying portion loc/id with leading forward slash (\emph{/})
  \begin{itemize}
    \item The identifying portion is split into three parts.
    \item \textbf{HIERARCHY}: is the \url{path/to/ontology-file}, with elements
      split by a forward slash (\emph{/}).
    \item \textbf{MEMBER:} is the element of the ontology at the specific
      position. It is being separated from the \textbf{HIERARCHY} by two
      forward slashes (\emph{//}). These forward slashes are also being used to
      separate members inside of \textbf{MEMBER} (e.g. in the case of a
      child-ontology which contains a symbol).
    \item \textbf{COMMAND}: is not really an element or part of an ontology,
      but a command the users wishes to execute on the element selected by the
      previous sections of the loc/id. It is denoted and separated from the
      rest of the IRI by the use of three consecutive forward slashes
      (\emph{///}).
  \end{itemize}
\end{enumerate}

\subsection{Examples}

\begin{tabularx}{\textwidth}{p{.2\textwidth}p{.8\textwidth}}
  \multicolumn{2}{c}{\emph{Distributed Ontology}} \\
  \hline
  Distributed Ontology & \url{/dol-testing/double_mapped_blendoid}\\
  Child Ontology & \url{/dol-testing/double_mapped_blendoid//DMB-CommonSource}\\
  Mapping & \url{/dol-testing/double_mapped_blendoid//SomeMapping}\\
  Symbol & \url{/dol-testing/double_mapped_blendoid//DMB-CommonSource//KitchenTable}\\
  Sentence & \url{/dol-testing/double_mapped_blendoid//DMB-CommonSource//Ax02}\\
  & \\
  \multicolumn{2}{c}{\emph{Ontology}} \\
  \hline
  Distributed Ontology & \url{/dol-testing/double_mapped_blendoid}\\
  Ontology & \url{/default/pizza}\\
  Mapping & \url{/default/pizza//SomeMapping}\\
  Symbol & \url{/default/pizza//Veneziana}\\
  Sentence & \url{/default/pizza//Ax02}\\
\end{tabularx}

Fully qualified symbols (e.g. $+:NatxNat\mapsto Nat$) will need to be escaped
but will be supported.

\section{Specification}

We can specify qualified loc/id IRIs as a special case of RFC 3987 (IRI,
\cite{rfc3987}). Code-excerpt \ref{lst:loc-id-spec} on page
\pageref{lst:loc-id-spec} contains this specification of qualified loc/ids in
Augmented Backus-Naur Form (ABNF, \cite{rfc5234}). We use ABNF here, because
RFC 3987 itself specifies IRIs using ABNF and we wanted to be able to reference
rules from the RFC in our specification. Such rules can be easily identified by
the \texttt{i}-prefix that was used when writing the IRI-rules.

\texttt{<Loc-Id-IRI>} represents the start rule for a qualified loc/id and
\texttt{<Loc-Id>} would be the starting non-terminal for a loc/id without its
\textbf{INSTANCE} qualifier. The following symbols are non-terminal symbols that
represent rules from the IRI-RFC.

\begin{itemize}
  \item \texttt{<iquery>}
  \item \texttt{<ifragment>}
  \item \texttt{<scheme>}
  \item \texttt{<iauthority>}
  \item \texttt{<isegment-nz>}
\end{itemize}

One should take note that the \texttt{<scheme>} rule does not include an
\texttt{i}-prefix.  This is because \texttt{<scheme>} is actually taken from
RFC 3986\cite{rfc3986}, which defines the URI.

\begin{figure}[b]
  \centering
  \lstinputlisting{loc_id.abnf}
  \caption[loc/id specification in ABNF]
   {Specification of loc/id IRIs in ABNF}
  \label{lst:loc-id-spec}
\end{figure}

\clearpage
\section{ref/ special form loc/ids}

There is one additional syntax-element that we haven't covered yet. One of the
main features that Ontohub provides in its role as an \emph{Open Ontology Repository}
is versioning of ontologies by backing the repositories with git. It is quite
important that we can access such versions and other related files inside of a
repository, which can be basically viewed as a directory in a filesystem.
\texttt{ref/}-style IRIs accomplish this task.

The \texttt{ref/\emph{argument}}-form is a prefix of the \textbf{HIERARCHY},
\textbf{MEMBER} and \textbf{COMMAND} components -- otherwise referred to as
unqualified loc/id, or in short: loc/id.

\begin{itemize}
  \item Version: \url{/ref/2/default/pizza//SomeMapping}
  \item Commit: \url{/ref/def3ab/default/pizza//SomeMapping}
  \item Branch: \url{/ref/master/default/pizza//SomeMapping}
  \item Date: \url{/ref/2014-09-07/default/pizza//SomeMapping}
    \begin{itemize}
      \item would take the latest commit which applies to the Date range.
    \end{itemize}
  \item MMT: \url{/ref/mmt/default/pizza?SomeMapping}
    \begin{itemize}
      \item Does not refer to a specifically designated version of the element,
        but always refers to the current one instead. This version allows to
        use MMT-style IRIs, which should guarantee basic support for tools
        which expect the MMT-style.
    \end{itemize}
\end{itemize}

\subsection{References inside of the tree}

Additionally we need to provide a way to reference files inside a repository,
This especially applies to files that do not represent ontologies. This
will be accomplished by the \texttt{tree/} special form. Additionally
we will support a \texttt{treeref} special form which allows to reference
a specific version of a files using the \emph{Commit}, \emph{Branch} and
\emph{Date} references. MMT is for obvious reasons not supported.

\begin{itemize}
  \item File: \url{/tree/default/some_directory/some_child_dir/Foo.txt}
    \begin{itemize}
      \item applies to HEAD commit of main branch (currently always \emph{master})
    \end{itemize}
  \item File at reference: \url{/treeref/{REF}/default/tree/some_directory/some_child_dir/Foo.txt}
    \begin{itemize}
      \item where \{REF\} is any of the above possible ref-types: Commit, Branch or Date
    \end{itemize}
\end{itemize}

\section{Disambiguating}

If the \url{path/to/an-ontology} can actually also be a path to a directory  --
which would be possible if there were a directory named \textbf{pizza} and an
ontology named \textbf{pizza.owl} -- will the loc/id be resolved to a
disambiguating page.

This page will contain a link to the tree for the directory, e.g.
\url{/tree/default/pizza}, and a link to a \texttt{ref/} special form
version of the ontology, e.g. \url{/ref/master/default/pizza}.

If however the loc/id is requested with a \emph{text/plain} content type we
will always serve the ontology. This is in part because there is no reasonable
representation of a directory that we would want to support. Another reason is
that Ontohub serves ontologies as its main objects. And as \emph{text/plain} is
the MIME-type that was chosen to always return the textual content of an
ontologies (the raw file), we will need to serve that, even if the loc/id would
be ambiguous in a normal request.

\bibliographystyle{ieeetr}
\bibliography{rfc}

\end{document}
