\documentclass[a4paper,11pt,DIV=22]{scrartcl}

\usepackage[utf8x]{inputenc}
% \usepackage[ngerman]{babel}
\usepackage{longtable}
\usepackage{listings}
%\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{hyperref}

\lstset{ %
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  % commentstyle=\color{mygreen},    % comment style
  % deletekeywords={...},            % if you want to delete keywords from the given language
  % escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  % keywordstyle=\color{blue},       % keyword style
  % morekeywords={*,...},            % if you want to add more keywords to the set
  % numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  % numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  % rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  % showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  % showstringspaces=false,          % underline spaces within strings only
  % showtabs=false,                  % show tabs within strings adding particular underscores
  % stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  % stringstyle=\color{mymauve},     % string literal style
  % tabsize=2,                       % sets default tabsize to 2 spaces
  % title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\author{Tim Reddehase}
\date{2015-02-22}

\newenvironment{oitemize}{%
  \renewcommand{\labelitemii}{$\bullet$}%
  \vspace{-15pt}
  \begin{itemize}}
  {\end{itemize}}

\begin{document}

\Huge
\begin{center}
  Ontohub loc/id (v2, Draft)\\
  \bigskip
  \includegraphics[width=0.3\textwidth]{ontohub-loc_id-logo.pdf}
\end{center}
\normalsize

\bigskip

\section{Concept}

Generally an Ontohub loc/id (locator/identifier) is just an IRI of an ontology
or one of its members (symbols, sentences, mappings, child-ontologies). However
Ontohub loc/ids are generated by the Ontohub application and assigned to an
ontology.  We try to infer them from the path of the repository, the path of
the ontology and the specific name. Additionally we ensure that this specific
IRI is actually a locator and not \emph{just} an identifier.

This is quite important as the IRI of an ontology is the general starting
interface a user has with the given ontology. When she evaluates the ontology
in her tool of choice she'll use the IRI to reference the given ontology. When
she wants to work on ontohub with the given ontology she'll point her browser
at the given IRI. As one familiarity with the Ontohub application increases one
will more often want to use the IRI instead of just searching or even browsing
for something.  This is further intensified if the IRI-schema follows a schema
that is easily understood by a user.

\section{Ontohub-Style}

Identifying Ontologies and their members in Ontohub is a hierarchical task. An
ontology belongs to a repository and a child-ontology belongs to a parent
ontology. Mappings, symbols and sentences in turn belong to a ontology. So we
could use the hierarchical portion of an IRI instead of the query string.
This would means using a forward slash (\emph{/}) as separator.

Ontohub loc/ids are specific to an instance of the Ontohub-Application. However
such an instance might be reachable via multiple multiple FQDNs (fully
qualified domain name) and ports. So instead we should expect a
\emph{qualified loc/id} to be a tuple consisting of the specific application
instance, represented by the set of their schema-fqdn-port tuples, and the
actual identifying portion beginning with the hierarchical forward slash
(\emph{/}).

\subsection{qualified loc/id structure}

\begin{enumerate}
  \item Set of Schema + FQDNs + Port for an instance: \textbf{INSTANCE}, e.g.\\
    \{ \url{http://localhost:3000}, \url{http://localhost:9001}, \url{http://ontohub.dev} \}
  \item Identifying portion loc/id with leading forward slash (\emph{/})
  \begin{itemize}
    \item The identifying portion is split into two parts.
    \item \textbf{HIERARCHY}: is the \url{path/to/ontology-file}, with elements
      split by a forward slash (\emph{/}).
    \item \textbf{MEMBER:} is the element of the ontology at the specific
      position. It is being separated from the \textbf{HIERARCHY} by two
      forward slashes (\emph{//}). These forward slashes are also being used to
      separate members inside of \textbf{MEMBER} (e.g. in the case of a
      child-ontology which contains a symbol).
    \item \textbf{COMMAND}: is not really an element or part of an ontology,
      but a command the users wishes to execute on the element selected by the
      previous sections of the loc/id. It is denoted and separated from the
      rest of the IRI by the use of three consecutive forward slashes
      (\emph{///}).
  \end{itemize}
\end{enumerate}

\subsection{Examples}

\begin{tabularx}{\textwidth}{p{.1\textwidth}p{.2\textwidth}p{.7\textwidth}}
  \emph{Distributed Ontology} & & \\
  \hline
  & Distributed Ontology & \url{/dol-testing/double_mapped_blendoid}\\
  & Child Ontology & \url{/dol-testing/double_mapped_blendoid//DMB-CommonSource}\\
  & Mapping & \url{/dol-testing/double_mapped_blendoid//SomeMapping}\\
  & Symbol & \url{/dol-testing/double_mapped_blendoid//DMB-CommonSource//KitchenTable}\\
  & Sentence & \url{/dol-testing/double_mapped_blendoid//DMB-CommonSource//Ax02}\\
  & & \\
  \emph{Ontology} & & \\
  \hline
  & Distributed Ontology & \url{/dol-testing/double_mapped_blendoid}\\
  & Ontology & \url{/default/pizza}\\
  & Mapping & \url{/default/pizza//SomeMapping}\\
  & Symbol & \url{/default/pizza//Veneziana}\\
  & Sentence & \url{/default/pizza//Ax02}\\
\end{tabularx}

Fully qualified symbols (e.g. $+:NatxNat->Nat$) will need to be escaped
but will be supported.

\section{Specification}

We can specify qualified loc/id IRIs as a special case of RFC 3987 (IRI,
\cite{rfc3987}). Code-excerpt \ref{lst:loc-id-spec} on page
\pageref{lst:loc-id-spec} contains this specification in Augmented Backus-Naur
Form (ABNF). We use ABNF here, because RFC 3987 itself specifies IRIs using
ABNF and we wanted to be able to reference rules from the RFC in our
specification. Such rules can be easily identified by the \texttt{i}-prefix
that was used when writing the IRI-rules.

\begin{figure}[b]
  \centering
  \lstinputlisting{loc_id.abnf}
  \caption[loc/id specification in ABNF]
   {Specification of loc/id IRIs in ABNF}
  \label{lst:loc-id-spec}
\end{figure}


\section{Other loc/id based IRIs}

\begin{itemize}
  \item Version: \url{/ref/2/default/pizza//SomeMapping}
  \item Commit: \url{/ref/def3ab/default/pizza//SomeMapping}
  \item Branch: \url{/ref/master/default/pizza//SomeMapping}
  \item Date: \url{/ref/2014-09-07/default/pizza//SomeMapping}
    \begin{itemize}
      \item would take the latest commit which applies to the Date range.
    \end{itemize}
  \item MMT: \url{/ref/mmt/default/pizza??SomeMapping}
    \begin{itemize}
      \item allows the use of fully compliant MMT-style
    \end{itemize}
  \item File: \url{/tree/default/some_directory/some_child_dir/Foo.txt}
    \begin{itemize}
      \item applies to HEAD commit of main branch (currently always \emph{master})
    \end{itemize}
  \item File at reference: \url{/treeref/{REF}/default/tree/some_directory/some_child_dir/Foo.txt}
    \begin{itemize}
      \item where \{REF\} is any of the above possible ref-types: Version, Commit, Branch or Date
    \end{itemize}
\end{itemize}

\section{Disambiguating}

If the \url{path/to/an-ontology} can actually also be a path to a directory  --
which would be possible if there were a directory named \textbf{pizza} and an
ontology named \textbf{pizza.owl} -- will the loc/id be resolved to a
disambiguating page. On this page will be a link to the tree for the directory
and a link to a \url{/ref/master/} qualified version of the ontology.

If however the loc/id is requested with a \emph{text/plain} content type we
will always serve the ontology.

\bibliographystyle{ieeetr}
\bibliography{rfc}

\end{document}
